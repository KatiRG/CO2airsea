<!DOCTYPE html>
<meta charset="utf-8">

<script src="d3.v3.min.js"></script>
<script src="lib/jquery-1.10.2.min.js"></script>
<script src="lib/topojson.v1.min.js"></script>
<!--bootstrap 3.0.2 -->
<link href="lib/bootstrap.css" rel="stylesheet">
<script src="lib/bootstrap.min.js"></script>
<link href="lib/sticky-footer-navbar.css" rel="stylesheet">
<link href="style.css" rel="stylesheet" type="text/css">
<script src="lib/colorbrewer.js"></script>

<title>CO2 Fluxes</title>

<body>
  <div id="wrap">

    <!-- Fixed navbar -->
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
        <div class="container">
          <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="index.html">Anthropogenic CO2 Fluxes</a>
          </div>
          <div class="collapse navbar-collapse">
            <ul class="nav navbar-nav">
              <li><a href="sankeyView.html" target="_blank">Sankey View</a></li>
            </ul>
          </div><!--/.nav-collapse -->
        </div>
      </div>
 
    <!-- Begin page content -->
    <div class="container">

      <div id="infotext" style="width: 700px;"></div>
      <div id="infotext2" style="width: 615px;"></div>

      <p id="chart">    

        <div id="sortCol"></div>

        <ul class="nytg-sort" style='position: absolute; left: 770px; top: 50px;'>
          <li id="resetMap">Reset</li>
        </ul>

      </p>

      <script src="sankey.js"></script>
      <script>
        var histfile = "orca05_absAnthroPerArea_TgPerYr.tsv", //orca05.tsv
            mapfile = "Continental_Shelf_v5_mapshaper_1pc_marcatsid.topojson",
            chartdiv = "Mchart",
            mapdiv = "Mmap",
            formatX = d3.format("02d"), //for numbering countries in stackedbar x-axis
            format = d3.format("5.2f"), //for tooltip values
            units = "Tg C yr <sup>-1</sup>",
            units_unitArea = "mol C m<sup>-2</sup> yr<sup>-1</sup>";

        d3.select("#resetMap").style("display", "list-item");

        plotHistogram(chartdiv, mapdiv);

        function plotHistogram(chartdiv, mapdiv) {

          d3.select("#infotext2").html("This stacked bar chart shows the anthropogenic carbon fluxes emitted by region class in terms of MARCATS surface area [Tg C yr <sup>-1</sup>]." + "<br/>" + "<br/>" + "<p>" + "Hover over each stacked bar to find the flux for the corresponding MARCATS region, as well as the flux per unit area [mol C m<sup>-2</sup> yr <sup>-1</sup>]." + "<br/>" + "<br/>" + "<p>")
            .style("display", "block");

          // http://www.d3noob.org/2013/01/adding-grid-lines-to-d3js-graph.html
          function make_y_axis() {
            return d3.svg.axis()
              .scale(y)
              .orient("left")
              .ticks(10)
          }

          var margin = {
              top: 0,
              right: 20,
              bottom: 120,
              left: 50
            },
            width = 600 - margin.left - margin.right,
            height = 700 - margin.top - margin.bottom;

          var x = d3.scale.ordinal()
            .rangeRoundBands([0, width], .1);

          var y = d3.scale.linear()
            .rangeRound([height, 0]);

          // Alphabetical Order of region names (Agulhas Current, Antarctic Shelves, etc.)
          // var marcat_colors = ["#ADB38D", "#084594", "#EB6841", "#2171b5", "#8c96c6", "#3FB8AF",
          //   "#AEC1BF", "#edf8fb", "#7FA0FF", "#ffa474", "#5a5443", "#b3cde3",
          //   "#DAD1B4", "#A09077", "#00A0B0", "#6A4A3C", "#99d8c9", "#006d2c",
          //   "#EDC951", "#66c2a4", "#9D928C", "#CC333F", "#FFFBD3", "#BFD0BB",
          //   "#b81b34", "#c6dbef", "#6baed6", "#DAD8A7", "#ccece6", "#7FC7AF",
          //   "#FF9E9D", "#F9D19C", "#FF3D7F", "#4292c6", "#8b0000", "#FCD5D3",
          //   "#C5B1AC", "#9ecae1", "#2ca25f", "#f47461", "#88419d", "#ffffe0",
          //   "#ffd59b", "#db4551", "#edf8fb"
          // ];

          var marcat_colors = [
            "#DAD1B4", "#084594", "#f7fcfd", "#2171b5", "#A6AED4", "#bfd3e6", 
            "#ADB38D", "#C4D4D1", "#6baed6", "#f47461", "#5a5443", "#8c96c6",
            "#AEC1BF", "#A09077", "#810f7c", "#8c96c6", "#2ca25f", "#ccece6",
            "#88419d", "#66c2a4", "#F9D19C", "#420040", "#BFD0BB", "#C5B1AC",
            "#8b0000", "#4292c6", "#c6dbef", "#9ebcda", "#99d8c9", "#e0ecf4",
            "#8c6bb1", "#FFFBD3", "#4d004b", "#9ecae1", "#b81b34", "#9D928C",
            "#FCD5D3", "#235CA6", "#006d2c", "#ffd59b", "#3C4055", "#ffa474",
            "#db4551", "#ffffe0", "#b3cde3"
          ];


          // Dictionary for MARCATS regions: RCLASS
          marcats_dict = {
            "NorthEasternPacific": "1",
            "CaliforniaCurrent": "2",
            "TropicalEasternPacific": "3",
            "PeruvianUpwellingCurrent": "4",
            "SouthernAmerica": "5",
            "BrazilianCurrent": "6",
            "TropicalWesternAtlantic": "7",
            "CaribbeanSea": "8",
            "GulfofMexico": "9",
            "FloridaUpwelling": "10",
            "SeaofLabrador": "11",
            "HudsonBay": "12",
            "CanadianArchipelagos": "13",
            "NorthernGreenland": "14",
            "SouthernGreenland": "18",
            "NorwegianBasin": "15",
            "NorthEasternAtlantic": "17",
            "BalticSea": "16",
            "IberianUpwelling": "19",
            "MediterraneanSea": "20",
            "BlackSea": "21",
            "MoroccanUpwelling": "22",
            "TropicalEasternAtlantic": "23",
            "SouthernWesternAfrica": "24",
            "AgulhasCurrent": "25",
            "TropicalWesternIndian": "26",
            "WesternArabianSea": "27",
            "RedSea": "28",
            "PersianGulf": "29",
            "EasternArabianSea": "30",
            "BayofBengal": "31",
            "TropicalEasternIndian": "32",
            "LeeuwinCurrent": "33",
            "SouthernAustralia": "34",
            "EasternAustrialianCurrent": "35",
            "NewZealand": "36",
            "NorthernAustralia": "37",
            "SouthEastAsia": "38",
            "ChinaSea&Kuroshio": "39",
            "SeaofJapan": "40",
            "SeaofOkhotsk": "41",
            "NorthWesternPacific": "42",
            "SiberianShelves": "43",
            "Barents&KaraSea": "44",
            "AntarcticShelves": "45"
          };

          // Define marcats groups to select all map regions belonging to same class
          var marcatsGroup, marcatsClass; //global var for mouseenter/mouseout on x-axis labels
          var marcatsGroups_dict = {
            "PolarMarcats": ".marcat-13, .marcat-14, .marcat-15, .marcat-18, .marcat-43, .marcat-44, .marcat-45",
            "MarginalMarcats": ".marcat-9, .marcat-12, .marcat-16, .marcat-17, .marcat-20, .marcat-21, .marcat-28, .marcat-29, .marcat-40, .marcat-41",
            "SubpolarMarcats": ".marcat-1, .marcat-5, .marcat-11, .marcat-34, .marcat-36, .marcat-42",
            "TropicalMarcats": ".marcat-3, .marcat-7, .marcat-8, .marcat-23, .marcat-26, .marcat-37, .marcat-38",
            "WBCMarcats": ".marcat-6, .marcat-10, .marcat-25, .marcat-35, .marcat-39",
            "EBCMarcats": ".marcat-2, .marcat-4, .marcat-19, .marcat-22, .marcat-24, .marcat-33",
            "IndianMarcats": ".marcat-27, .marcat-30, .marcat-31, .marcat-32"
          };
          
          var class_dict = {
            "EBC": ".classCaliforniaCurrent, .classIberianUpwelling, .classLeeuwinCurrent, .classMoroccanUpwelling, .classPeruvianUpwellingCurrent, .classSouthernWesternAfrica",
            "Indian margins": ".classBayofBengal, .classEasternArabianSea, .classTropicalEasternIndian, .classWesternArabianSea",
            "WBC": ".classAgulhasCurrent, .classBrazilianCurrent, .classChinaSeaKuroshio, .classEasternAustrialianCurrent, .classFloridaUpwelling",
            "Tropical": ".classCaribbeanSea, .classNorthernAustralia, .classSouthEastAsia, .classTropicalEasternAtlantic, .classTropicalEasternPacific, .classTropicalWesternAtlantic, .classTropicalWesternIndian",
            "Subpolar": ".classNewZealand, .classNorthEasternPacific, .classNorthWesternPacific, .classSeaofLabrador, .classSouthernAmerica, .classSouthernAustralia",
            "Marginal sea": ".classBalticSea, .classBlackSea, .classGulfofMexico, .classHudsonBay, .classMediterraneanSea, .classNorthEasternAtlantic, .classPersianGulf, .classRedSea, .classSeaofJapan, .classSeaofOkhotsk",
            "Polar": ".classAntarcticShelves, .classBarentsKaraSea, .classCanadianArchipelagos, .classNorthernGreenland, .classNorwegianBasin, .classSiberianShelves, .classSouthernGreenland"
          };

          var color = d3.scale.ordinal()
            // .range([Coal_color, Oil_color, Gas_color, GasFlaring_color, Cement_color]);
            .range(marcat_colors);

          // var map_colourbar = d3.scale.quantize()
          //       .domain([minflux, maxflux])
          //       .range(colorbrewer.Greys[5]);  

          var active_bar = d3.select(null), //for mouseenter / mouseout on stacked bar
              clicked_bar = d3.select(null); //for clicking stacked bar
          //var store_fill; //store fill colour of map region corresponding to clicked stacked bar
          var globalg; //global g for paths
          var zoomRegion = -999; //global var for region to zoom

          var xAxis = d3.svg.axis()
            .scale(x)
            .orient("bottom");

          var yAxis = d3.svg.axis()
            .scale(y)
            .orient("left")
            //.tickFormat(d3.format(".2s"))
            .tickFormat(d3.format(".2f"));

          // append the chart div to <p id="chart">
          var svg3 = d3.select("#chart").append("div").attr("id", chartdiv)
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

          // add chart title
          d3.select("#" + chartdiv)
            .append("div")
            .attr("class", "class_chartTitle")
            .append("h4")
            .append("foreignObject")
            .html("Anthropogenic CO2 flux [Tg C yr<sup>-1</sup>]");
           


          var div = d3.select("body").append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);

          // Read in datafile for stacked bar chart
          // ======================================
          d3.tsv(histfile, function(error, data) {
            if (error) throw error;

            color.domain(d3.keys(data[0]).filter(function(key) {
              if (key) {
                //console.log("key: ", key)
                return key !== "RCLASS"; //Region names
              }
            }));

            data.forEach(function(d) {
              var y0 = 0;
              // Stack bars in order of value
              //http://stackoverflow.com/questions/25253834/sorting-a-d3-js-stacked-bar-chart
              var order = color.domain().map(function(d) { return d; })
                 .sort(function(a, b) { return +d[b] - +d[a]; });
              //d.sources = color.domain().map(function(name) {
              d.sources = order.map(function(name) {  
                return {
                  country: d.RCLASS,
                  name: name,
                  y0: y0,
                  y1: y0 += +d[name],
                  value: d[name],
                  ycoord_corrected: 0
                };
              });              
              d.total = d.sources[d.sources.length - 1].y1;

            });

            // sort totals in descending order
            data.sort(function(a, b) {
              return b.total - a.total;
            });

            x.domain(data.map(function(d) {
              return d.RCLASS;
            }));
            y.domain([0, d3.max(data, function(d) {
              return d.total;
            })]);
            
            svg3.append("g")
              .attr("class", "x axis")
              .attr("transform", "translate(0," + height + ")")
              .call(xAxis)
              .selectAll("text") //http://www.d3noob.org/2013/01/how-to-rotate-text-labels-for-x-axis-of.html
              .text(function(d, i) {
                return d + " - " + formatX(i + 1);
              })
              .style("fill", "#2f2f2f")
              .style("text-anchor", "end")
              //.style("font-size","12px")
              .attr("dx", "-.8em")
              .attr("dy", ".15em")
              .attr("transform", "rotate(-65)")
              .on("mouseenter", function (d) {
                console.log("d: ", d)

                d3.select(this).style("cursor", "pointer")
                           
                marcatsGroup = d3.select(this).text().split(/\s+/)[0] + "Marcats";
                // outline all marcats regions belonging to this class
                d3.selectAll(marcatsGroups_dict[marcatsGroup]).classed("outline", true);

                // outline all stacked bars in this class
                marcatsClass = class_dict[d];                
                d3.selectAll(marcatsClass).classed("active_bar", true);

              })
              .on("mouseout", function (d) {                
                // remove outline on stacked bars and map regions
                d3.selectAll(marcatsGroups_dict[marcatsGroup]).classed("outline", false);              
                d3.selectAll(marcatsClass).classed("active_bar", false);

              });

            svg3.append("g")
              .attr("class", "y axis")
              .call(yAxis)
              .append("text")
              .style("font-size","12px")
              .attr("transform", "rotate(-90)")
              .attr("y", 6)
              .attr("dy", ".71em")
              .style("text-anchor", "end");
            //.text("Population");

            svg3.append("g")
              .attr("class", "grid")
              .call(make_y_axis()
                .tickSize(-width, 0, 0)
                .tickFormat("")
              )

            // country nodes
            var state = svg3.selectAll(".state")
              .data(data)
              .enter().append("g")
              .attr("class", function(d) {
                // tag g node of stacked bars with country name
                return "g Country";
              })
              .attr("id", function(d) {
                return "id_" + d.RCLASS.replace(/\s/g, '');
              });

            // country rects  
            height_diff = 0;
            state.selectAll("rect")
              .data(function(d) {
                return d.sources;
              })
              .enter().append("rect")
              .attr("width", x.rangeBand())
              .attr("y", function(d) {
                h_orig = y(d.y0) - y(d.y1); //based on stacked values (inaccurate)
                h_correct = y(0) - y(d.value); //based on data value in csv file
                height_diff = height_diff + h_orig - h_correct;

                //correct y-coord
                ycoord_corrected = y(d.y1) + height_diff;
                d.ycoord_corrected = ycoord_corrected //store in d for later use in restorePlot()

                if (d.name === "Cement") height_diff = 0; //reset for next set of stacked bars

                return ycoord_corrected;

              })
              .attr("x", function(d) { //add to stock code
                return x(d.country)
              })
              .attr("height", function(d) {
                return y(0) - y(d.value); //heights calculated based on data value (accurate)
              })
              .attr("class", function(d) {
                if (d.value != 0) {
                  classLabel = d.name.replace(/\s/g, '').replace(/&/g, ''); //remove spaces and '&'
                  areaFlux = d.value;
                  return "bars class" + classLabel + " areaflux-" + areaFlux;
                }
              })
              .style("fill", function(d) {
                //console.log("color(d.name): ", d.name +", "+ color(d.name))
                return color(d.name);              
              });

            // country rects event handlers
            state.selectAll("rect")
              .on("mouseenter", function(d) {                
                d3.select(this).style("cursor", "pointer");
                d3.select(".tooltip").style("display", "block");                

                // outline clicked stacked bar
                active_bar = d3.select(this).classed("active_bar", true);  

                // toggle active state of stacked bar to outline/de-outline it
                // if (active_bar.node() === this) return reset_bar();
                // active_bar.classed("active_bar", false);

                // toolip. Get unitflux value stored in class of map region path
                var this_class = d3.select(this).attr("class");
                class_to_match = get_mapClass(this_class);                

                if (d3.select(this).style("opacity") != 0) {
                  var unitflux = d3.select(class_to_match).attr("class")
                                   .split(/\s+/)[2].split("unitflux-").pop();

                  var xPos = parseFloat(d3.select(this).attr("x"));
                  var yPos = parseFloat(d3.select(this).attr("y"));
                  var height = parseFloat(d3.select(this).attr("height"))

                  div.transition().style("opacity", .9);
                  div.html(d.country + ": " + d.name + "<br><br><b>" 
                           + format(d.value) + " " + units + "  (area flux)" + "</b>"
                           + "<br>" + format(unitflux) + " " + units_unitArea + "  (unit flux)")
                    .style("left", (d3.event.pageX + 20) + "px")
                    .style("top", (d3.event.pageY - 20) + "px");
                }

                // highlight corresponding areas on map
                //fill_orig = d3.select(class_to_match).style("fill");                
                d3.selectAll(class_to_match)
                  .classed("outline", true);

              })
              .on("mouseout", function() {

                var this_barRegion = marcats_dict[d3.select(this).attr("class").split(/\s+/)[1].split("class").pop()];

                // remove outline on stacked bar if not clicked
                if (this_barRegion != zoomRegion) reset_bar();

                d3.select(this).style("cursor", "auto");

                // remove tooltip display
                div.transition().style("opacity", 0);

                // restore map region to orig colour
                d3.selectAll(class_to_match)
                  .classed("outline", false);                  

              })
              .on("click", function(d) {
                d3.select(".tooltip").style("display", "block");

                if (clicked_bar.node() === this && d3.select(this).classed("clicked_bar") === true) {
                  clicked_bar = d3.select(this).classed("clicked_bar", false);
                  return resetMap();
                }

                clicked_bar = d3.select(this).classed("clicked_bar", true);

                // zoom corresponding map region
                zoomRegion = parseInt(marcats_dict[d.name.replace(/\s/g, '')]);
                plotMap();

                // clear any previously clicked stacked bar
                d3.selectAll(".active_bar")
                  .classed("active_bar", false)
                  .attr("stroke", null);

                // outline clicked stacked bar
                active_bar = d3.select(this).classed("active_bar", true);          
                
              });

            function reset_bar() {
              active_bar.classed("active_bar", false)
                        .attr("stroke", null);

              active_bar = d3.select(null);

              // // clear any previously clicked map region
              // d3.selectAll('.feature.active')
              //   .classed("active", false)
              //   .style("fill", store_fill);
            }

          }); //d3.tsv(histfile)

          function get_mapClass(this_class) { //get class of map region corresponding to stacked bar
            
            var classMarcats = this_class.split(/\s+/)[1];
            if ( classMarcats === "classBarentsKaraSea") classMarcats = "classBarents&KaraSea";
            else if ( classMarcats === "classChinaSeaKuroshio") classMarcats = "classChinaSea&Kuroshio";
            
            var class_to_match = ".marcat-" + marcats_dict[classMarcats.split("class").pop()];

            return class_to_match;
          }

          //===================================================
          //MAP

          // Read in flux values per unit area
          // ======================================

          d3.tsv("orca05_absAnthroUnitArea.tsv", function(error, unitdata) {
              if (error) throw error;

              // Create an array to store unit flux values, indexed by MARCATS_ID
              var unit_dict = new Array();
              unit_dict[0] = -999; //there is no MARCAT_ID = 0

              // Store min and max unit flux values for map colourbar
              var minflux = 99999,
                maxflux = -99999;
              unitdata.forEach(function(d) {
                d.abs_anthro = +d.abs_anthro; //set to num
                d.MARCATS_ID = +d.MARCATS_ID;
                minflux = d.abs_anthro < minflux ? d.abs_anthro : minflux;
                maxflux = d.abs_anthro > maxflux ? d.abs_anthro : maxflux;

                unit_dict[d.MARCATS_ID] = d.abs_anthro;

              });

              // must use quantize http://stackoverflow.com/questions/26817035/colorbrewer-scale-only-returning-lightest-values-on-d3-map
              var map_colourbar = d3.scale.quantize()
                .domain([minflux, maxflux])
                .range(colorbrewer.Greys[5]);

              plotMap(unit_dict, map_colourbar);

            }) //end d3.tsv

          function plotMap(unit_dict, map_colourbar) {

            var unit_flux = [];

            // append the mapdiv to <p id="chart">
            var m_width = 960,
              m_height = 700,
              outline = d3.select(null);
            //active = d3.select(null);

            var projection = d3.geo.mercator()
              .translate([m_width / 2, m_height / 1.5]);

            var path = d3.geo.path().projection(projection);
            var t = projection.translate(); // the projection's default translation
            var s = projection.scale(110) // the projection's default scale        

            var path = d3.geo.path()
              .projection(projection);

            // var zoom = d3.behavior.zoom()
            //   .on("zoom", zoomed);
            // svg4
            //   .call(zoom); // delete this line to disable free zooming

            //http://stackoverflow.com/questions/34556761/fixing-zoom-jump-when-scaling-map
            //world map with zoom and pan: https://bl.ocks.org/d3noob/5189284

            // reset map button
            d3.select("#resetMap")
              .on("click", function() {
                return resetMap();
              });

            d3.json("refs/" + mapfile, function(error, us) {
              if (error) throw error;            

              if (zoomRegion === -999) { //plot map for first time (no stacked bar clicked)

                var svg4 = d3.select("#chart").append("div").attr("id", mapdiv)
                  .append("svg")
                  .attr("width", m_width + margin.left + margin.right)
                  .attr("height", m_height + margin.top + margin.bottom);

                svg4.append("rect")
                  .attr("class", "background")
                  .attr("width", m_width)
                  .attr("height", m_height)
                  //.on("click", reset);

                //var g = svg.append("g")
                globalg = svg4.append("g")
                  .style("stroke-width", "1.5px");

                globalg.selectAll("path")
                  .data(topojson.feature(us, us.objects.Continental_Shelf_v5).features)
                  .enter().append("path")
                  .attr("d", path)
                  .attr("class", function(d) {
                    // add abs anthro unit flux to class so stacked bar can get value
                    return "feature"
                           + " marcat-" + d.properties.MARCATS
                           + " unitflux-" + unit_dict[d.properties.MARCATS];
                  })
                  .style("fill", function (d, i) {
                    unit_flux[i] = unit_dict[d.properties.MARCATS];                    
                    return map_colourbar(unit_flux[i]);
                  })
                  .attr("id", function(d) {
                    return "id-" + d.properties.COSCAT;
                  })
                  .on("mouseenter", function (d, i) {
                    d3.select(".tooltip").style("display", "block");

                    //outline all map regions of same MARCATS
                    outline.classed("outline", false);
                    var this_class = d3.select(this).attr("class").split(/\s+/)[1];
                    outline = d3.selectAll("." + this_class).classed("outline", "true");

                    //outline corresponding stacked bar (and handle '&'' cases)
                    var matching_barClass = getKeyByValue(marcats_dict, 
                                               this_class.split("marcat-").pop());
                    if (matching_barClass === "Barents&KaraSea") 
                      matching_barClass = "BarentsKaraSea";
                    else if (matching_barClass === "ChinaSea&Kuroshio") 
                      matching_barClass = "ChinaSeaKuroshio";                    
                    d3.select(".class" + matching_barClass).classed("active_bar", true);

                    // tooltip
                    var marcats_string = getKeyByValue(marcats_dict, d.properties.MARCATS);
                    // Remove & to match class label
                    if ( marcats_string === "Barents&KaraSea") marcats_string = "BarentsKaraSea";
                    else if ( marcats_string === "ChinaSea&Kuroshio") 
                      marcats_string = "ChinaSeaKuroshio";

                    if (d3.select(this).style("opacity") != 0) {
                      // Read areaflux stored in class of stackedbar
                      var areaflux = d3.select(".class" + marcats_string)
                                       .attr("class")
                                       .split(/\s+/)[2]
                                       .split("areaflux-").pop();

                      var xPos = parseFloat(d3.select(this).attr("x"));
                      var yPos = parseFloat(d3.select(this).attr("y"));
                      var height = parseFloat(d3.select(this).attr("height"))

                      // Format to un-camelCase and insert & for two regions
                      var marcats_string_format = marcats_string.split(/(?=[A-Z])/).join(' ');
                      if (marcats_string_format === "Barents Kara Sea") 
                        marcats_string_format = "Barents & Kara Sea";
                      else if (marcats_string_format === "China Sea Kuroshio") 
                        marcats_string_format = "China Sea & Kuroshio";
                      else if (marcats_string_format === "Bayof Bengal") 
                        marcats_string_format = "Bay of Bengal";
                      else if (marcats_string_format === "Gulfof Mexico") 
                        marcats_string_format = "Gulf of Mexico";
                      else if (marcats_string_format === "Seaof Japan") 
                        marcats_string_format = "Sea of Japan";
                      else if (marcats_string_format === "Seaof Labrador") 
                        marcats_string_format = "Sea of Labrador";
                      else if (marcats_string_format === "Seaof Okhotsk") 
                        marcats_string_format = "Sea of Okhotsk";
                      
                      div.transition().style("opacity", .9);
                      div.html(marcats_string_format + ": " + "<br><br><b>"
                               + format(areaflux) + " " + units + "  (area flux)" + "</b>" + "<br>"
                               + format(unit_flux[i]) + " " + units_unitArea + "  (unit flux)")
                         .style("left", (d3.event.pageX + 20) + "px")
                         .style("top", (d3.event.pageY - 20) + "px");
                    }
                  })
                  .on("mouseout", function (d) {
                    d3.select(".tooltip").style("display", "none");

                    // remove outline of map regions
                    d3.selectAll(".outline").classed("outline", false);

                    // remove outline on stackedbar
                    d3.select(".active_bar").classed("active_bar", false);
                  });                

                globalg.append("path")
                  .datum(topojson.mesh(us, us.objects.Continental_Shelf_v5, function(a, b) {
                    return a !== b;
                  }))
                  .attr("class", "mesh")
                  .attr("d", path);

              } else { //zoom region corresponding to clicked stacked bar                

                globalg.selectAll("path") 
                  .filter(function(d) {

                    if (d.properties && d.properties.MARCATS === zoomRegion) {
                      getBounds(path, d, m_width, m_height);
                    }

                  });
              }


            }); //end d3.json

            // use to get reverse of marcats_dict dictionary
            function getKeyByValue(hash, value) {
              var key;
              for(key in hash) {
                if (hash[key] == value) return key;
              }
            }


          } //end fn plotMap()

          //=================
          // Fns for map
          function getBounds(path, d, m_width, m_height) {

            var bounds = path.bounds(d),
              dx = bounds[1][0] - bounds[0][0],
              dy = bounds[1][1] - bounds[0][1],
              x = (bounds[0][0] + bounds[1][0]) / 2,
              y = (bounds[0][1] + bounds[1][1]) / 2,
              scale = .2 / Math.max(dx / m_width, dy / m_height), //orig scale factor = .9
              translate = [m_width / 2 - scale * x, m_height / 2 - scale * y];

            globalg.transition()
              .duration(750)
              .style("stroke-width", 1.5 / scale + "px")
              .attr("transform", "translate(" + translate + ")scale(" + scale + ")");

          }

          // function clicked(d) {
          //   if (outline.node() === this) return reset();
          //   outline.classed("outline", false);
          //   outline = d3.select(this).classed("outline", true);

          //   var bounds = path.bounds(d),
          //     dx = bounds[1][0] - bounds[0][0],
          //     dy = bounds[1][1] - bounds[0][1],
          //     x = (bounds[0][0] + bounds[1][0]) / 2,
          //     y = (bounds[0][1] + bounds[1][1]) / 2,
          //     scale = .2 / Math.max(dx / m_width, dy / m_height), //orig scale factor = .9
          //     translate = [m_width / 2 - scale * x, m_height / 2 - scale * y];

          //   g.transition()
          //     .duration(750)
          //     .style("stroke-width", 1.5 / scale + "px")
          //     .attr("transform", "translate(" + translate + ")scale(" + scale + ")");
          // }

          function resetMap() {
            // outline.classed("outline", false);
            // outline = d3.select(null);
            d3.select(".outline").classed("outline", false)

            globalg.transition()
              .duration(750)
              .style("stroke-width", "1.5px")
              .attr("transform", "");
            
            // clear outline of clicked stacked bar
            d3.selectAll(".active_bar")
              .classed("active_bar", false)
              .attr("stroke", null);

            // clear tooltip
            d3.select(".tooltip").style("display", "none");            

          }


        } //end plotHistogram()
      </script>

    </div>
    <!-- /.container -->
  </div>
  <!-- /.wrap -->

  <!--<div id="footer">
    <div class="container">
      <p class="text-muted credit"><span title="Climate and Environment Sciences Laboratory" style="font-weight:bold;">LSCE</span> &nbsp;<img src="LSCE_Icon.png" title="Climate and Environment Sciences Laboratory" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Version 1.3 - 2016/02/05 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Authors: Cathy Nangini, Patrick Brockmann.</p>

    </div>
  </div>-->

</body>

</html>